# Складання розкладу занять за допомогою жадібного алгоритму

Реалізуйте програму для складання розкладу занять в університеті, використовуючи жадібний алгоритм для задачі покриття множини.
Мета полягає в призначенні викладачів на предмети таким чином, щоб мінімізувати кількість викладачів та покрити всі предмети.

## Технічні умови

- Дано множину предметів: {'Математика', 'Фізика', 'Хімія', 'Інформатика', 'Біологія'}

- Список викладачів:

  1. Олександр Іваненко, 45 років, o.ivanenko@example.com, предмети: {'Математика', 'Фізика'}

  2. Марія Петренко, 38 років, m.petrenko@example.com, предмети: {'Хімія'}

  3. Сергій Коваленко, 50 років, s.kovalenko@example.com, предмети: {'Інформатика', 'Математика'}

  4. Наталія Шевченко, 29 років, n.shevchenko@example.com, предмети: {'Біологія', 'Хімія'}

  5. Дмитро Бондаренко, 35 років, d.bondarenko@example.com, предмети: {'Фізика', 'Інформатика'}

  6. Олена Гриценко, 42 роки, o.grytsenko@example.com, предмети: {'Біологія'}

## Опис завдання

- Реалізуйте клас Teacher з такими атрибутами:
  first_name (ім'я)
  last_name (прізвище)
  age (вік)
  email (електронна пошта)
  can_teach_subjects (множина предметів, які може викладати)
- Реалізуйте функцію create_schedule(subjects, teachers), яка використовує жадібний алгоритм для призначення викладачів на предмети. Функція повинна повернути список викладачів та предмети, які їм призначено.
- Під час вибору викладача на кожному етапі віддавайте перевагу тому, хто може викладати найбільшу кількість предметів, які ще не охоплені. Якщо таких кандидатів кілька, обирайте наймолодшого за віком.

## Критерії прийняття

1. Програма покриває всі предмети з множини предметів (40 балів).

2. Якщо неможливо покрити всі предмети наявними викладачами, програма повинна вивести повідомлення про це (30 балів).

3. Усі предмети мають бути покриті викладачами, а усі викладачі — призначені відповідно своїм предметам (30 балів).

## Шаблон програми

```Python

# Визначення класу Teacher
class Teacher:
    pass

def create_schedule(subjects, teachers):
   pass

if __name__ == '__main__':
    # Множина предметів
    subjects = {}
    # Створення списку викладачів
    teachers = []

    # Виклик функції створення розкладу
    schedule = create_schedule(subjects, teachers)

    # Виведення розкладу
    if schedule:
        print("Розклад занять:")
        for teacher in schedule:
            print(f"{teacher.first_name} {teacher.last_name}, {teacher.age} років, email: {teacher.email}")
            print(f"   Викладає предмети: {', '.join(teacher.assigned_subjects)}\\n")
    else:
        print("Неможливо покрити всі предмети наявними викладачами.")

```

## Рішення

### Задача Set Cover (покриття множини):

Маємо універсальну множину U (у нашому випадку — всі предмети) і набір підмножин S₁, S₂, …, Sₙ (предмети, які може викладати кожен викладач).
Мета — знайти найменшу кількість підмножин, об’єднання яких дорівнює U.

Оскільки точне розв’язання NP-повне, ми застосовуємо жадібний наближений алгоритм:

1. На кожному кроці обираємо викладача, який покриває найбільше непокритих предметів.

2. Якщо кілька таких — обираємо молодшого за віком.

3. Повторюємо, доки всі предмети не будуть покриті або неможливо знайти нового викладача.

### Структура програми

#### Клас Teacher

- зберігає інформацію про викладача (ім’я, прізвище, вік, email, предмети, які може викладати);

- атрибут assigned_subjects зберігає предмети, які йому призначені.

#### Функція create_schedule(subjects, teachers)

- приймає множину предметів і список викладачів;

- повертає список викладачів, які покривають усі предмети, або None, якщо це неможливо.

#### Обробка помилок

Якщо жоден викладач не може покрити ще непокриті предмети —
функція повертає None, а програма виводить повідомлення:

```
Неможливо покрити всі предмети наявними викладачами.

```

### Висновок

Цей приклад демонструє:

- Як жадібний алгоритм застосовується до реальної задачі.

- Як можна додати критерій пріоритету (вік).

- Як просто адаптувати класичну NP-повну задачу до практичного сценарію.
